# 计算属性，methods，watch，watcheffect区别

这四个概念是 Vue 响应式系统的核心，面试和实战中都非常高频。为了让你彻底理解，我将它们分为两组进行对比：

1.  **数据的产出与计算**：`Computed` vs `Methods`
2.  **侦听与副作用**：`Watch` vs `WatchEffect`

---

### 第一组：Computed vs Methods

**核心区别：是否有缓存**

#### 1. Computed (计算属性)

*   **定义**：基于现有的响应式数据，**派生**出一个新的值。
*   **特性**：**具缓存性 (Caching)**。
    *   只要它依赖的数据（Dependencies）没有发生变化，无论你访问多少次 `computed` 属性，它都不会重新运行，而是直接返回之前的计算结果。
    *   只有依赖变化时，才会重新计算。
*   **适用场景**：一个数据受多个数据影响（多对一）。例如：`全名 = 姓 + 名`，`购物车总价 = 单价 * 数量`。

#### 2. Methods (方法)

*   **定义**：普通的函数。
*   **特性**：**无缓存**。
    *   只要页面发生重绘（Render），或者你主动调用它，它**每一次都会执行**。
*   **适用场景**：处理事件（点击事件）、复杂的业务逻辑函数，或者不需要缓存的即时计算。

#### ⚔️ 对比代码

```javascript
<template>
  <div>
    <!-- 使用 Computed：只打印一次 "Computed run"，后面直接复用结果 -->
    <p>{{ nowComputed }}</p>
    <p>{{ nowComputed }}</p>

    <!-- 使用 Method：会打印两次 "Method run" -->
    <p>{{ nowMethod() }}</p>
    <p>{{ nowMethod() }}</p>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'

const count = ref(0)

// Computed: 依赖 count。只要 count 不变，它就永远不重新跑
const nowComputed = computed(() => {
  console.log('Computed run') // 只有 count 变了才会打印
  return Date.now() + count.value
})

// Method: 只要页面刷新（re-render），它就跑
const nowMethod = () => {
  console.log('Method run')
  return Date.now() + count.value
}
</script>
```

---

### 第二组：Watch vs WatchEffect

**核心区别：显式指定依赖 vs 自动收集依赖**，以及 **惰性执行 vs 立即执行**。

这俩都是用于处理**副作用 (Side Effects)** 的，比如：数据变了去发网络请求、手动修改 DOM、打印日志等。

#### 3. Watch (侦听器)

*   **特点**：
    1.  **懒执行 (Lazy)**：默认情况下，初始化时不执行，只有当监听的数据源变了才执行（除非设置 `immediate: true`）。
    2.  **显式指定依赖**：你必须明确告诉 Vue 你要盯着哪个变量。
    3.  **获取新旧值**：它可以拿到 `(newValue, oldValue)`。
*   **适用场景**：
    *   当你需要在数据变化时执行异步操作（API 请求）。
    *   当你需要对比新旧值（比如：只有当新值大于旧值时才执行）。
    *   一个数据影响多个数据（一对多）。

#### 4. WatchEffect (副作用侦听器 - Vue 3 特有)

*   **特点**：
    1.  **立即执行 (Eager)**：组件初始化时，它**立即就会执行一次**（为了收集依赖）。
    2.  **自动收集依赖**：你不需要告诉它盯着谁。**它在执行过程中用到了谁，它就自动盯着谁**。
    3.  **拿不到旧值**：它只关心当前状态，无法获取变化前的值。
*   **适用场景**：
    *   逻辑比较简单，且依赖项很多，不想一个一个手写监听源。
    *   比如：根据几个筛选条件（ID、Type、Page）去自动请求 API。

#### ⚔️ 对比代码

```javascript
import { ref, watch, watchEffect } from 'vue'

const count = ref(0)
const name = ref('Vue')

// 1. Watch: 必须明确说 "我要盯着 count"
// 默认不执行，count 变了才执行
// 可以拿到旧值
watch(count, (newVal, oldVal) => {
  console.log(`Watch: count 变了，从 ${oldVal} 变成了 ${newVal}`)
})

// 2. WatchEffect: 不需要说盯着谁
// ❌ 缺点：拿不到旧值
// ✅ 优点：初始化立刻执行一次；
// 内部用到了 count 和 name，所以只要这俩任何一个变了，它都会重新跑
watchEffect(() => {
  console.log(`WatchEffect: 自动检测到变化`, count.value, name.value)
  // 这里比如发起一个请求：
  // fetch(`/api/user?count=${count.value}&name=${name.value}`)
})
```

---

### 总结：一图胜千言

| 特性               | Computed (计算属性)         | Methods (方法)                | Watch (侦听器)                   | WatchEffect (副作用)            |
| :----------------- | :-------------------------- | :---------------------------- | :------------------------------- | :------------------------------ |
| **是否有缓存**     | ✅ **有** (依赖不变不计算)   | ❌ **无** (每次都执行)         | ❌ 无                             | ❌ 无                            |
| **是否产生副作用** | ❌ **不推荐** (只应返回数据) | ✅ 可以                        | ✅ **专门用于副作用** (API请求等) | ✅ **专门用于副作用**            |
| **依赖收集方式**   | 自动收集                    | 无                            | **显式指定** (手动写源)          | **自动收集** (用到谁盯谁)       |
| **初始化执行**     | 访问时执行                  | 调用时执行                    | ❌ 默认不执行 (除非 immediate)    | ✅ **立即执行**                  |
| **新旧值获取**     | 无                          | 无                            | ✅ **可获取 (new, old)**          | ❌ 无法获取                      |
| **经典比喻**       | **Excel 公式** (自动更新)   | **计算器按键** (按一下算一下) | **监控摄像头** (盯着特定的门)    | **红外感应灯** (哪里有人动就亮) |

### 什么时候用哪个？（决策指南）

1.  **我要根据 A 算出 B，并且 B 要展示在模板里？**
    *   👉 **Computed** (首选，性能最高)。
2.  **点击按钮要执行一个逻辑？或者算法很简单不需要缓存？**
    *   👉 **Methods**。
3.  **数据变了，我要去发请求、操作 LocalStorage、或者控制其他非数据的东西？**
    *   👉 **Watch** 或 **WatchEffect**。
    *   *细分*：
        *   需要新旧值对比？或者不想刚进入页面就触发？用 **Watch**。
        *   依赖很多，懒得一个个写，且希望一上来就跑一次？用 **WatchEffect**。




### methods并不具备“响应式” (Reactivity)。

它只是一个**普通的 JavaScript 函数**。

为了让你彻底明白，我们需要拆解一下“响应式”和“函数执行”的区别：

#### 1. 为什么它看起来像是“响应式”的？

你可能会觉得：“哎？可是当我修改 `count.value` 时，页面上 `{{ nowMethod() }}` 的数字确实变了呀，这难道不是响应式吗？”

**真相是这样的：**

1.  你修改了 `count.value`（这是一个 `ref`，它是响应式的）。
2.  **组件（Component）** 检测到了数据变化，触发了 **重新渲染 (Re-render)**。
3.  在重新渲染的过程中，Vue 会重新读取模板（Template）。
4.  模板里写着 `{{ nowMethod() }}`，所以**函数被重新调用了一次**。
5.  函数执行，读取到最新的 `count`，返回新结果，显示在页面上。

**结论**：是被响应式的 `count` 带着跑的，而不是它自己有响应性。



如果在页面上修改 `msg.value`（比如变成 'Hi'）：

1.  **Computed**：**完全不动**。因为它知道 `msg` 跟它没关系，它会直接用缓存的值。
2.  **Method**：**会被强制执行一次！**
    *   因为 `msg` 变了 -> 组件重绘 -> 模板重新解析 -> 遇到 `{{ nowMethod() }}` -> **函数再次执行**。

#### 2. 什么时候用哪个？

*   如果你想**展示数据**（比如 `Date.now() + count`），**请务必使用 `computed`**。
    *   原因：如果不因依赖变化而变化，Method 会导致大量无意义的重复计算，浪费性能。
*   如果你是**响应事件**（比如 `@click="handleClick"`），**请使用 `methods`**。
    *   原因：点击才触发，不需要缓存，也不需要追踪依赖。

**一句话总结：**
`nowMethod` 只是一个打工人，老板（组件）让它干活（渲染）它就干活，它自己不知道数据变没变，也不关心数据变没变。





##  `watch` 的第一个参数是活的引用

你现在的困惑在于：**你觉得 `watch` 的第一个参数只是用来“指定名字”的，但实际上第一个参数必须是一个“活的引用”。**

我用一个最通俗的 **“送快递”** 的例子来给你彻底讲明白。

---

### 1. 根本原因：JS 的“死值”与“活值”

假设你有一个 `reactive` 对象：
```javascript
const state = reactive({ count: 0 })
```

#### ❌ 错误写法：`watch(state.count, ...)`

在 JavaScript 中，**数字（Number）是基本数据类型，它是“按值传递”的**。

当你写 `watch(state.count, ...)` 时，代码执行流程是这样的：
1.  JS 引擎先读取 `state.count` 的值。此时是 `0`。
2.  JS 把 `0` 传给了 `watch` 函数。
3.  **实际上代码变成了这样：** `watch(0, ...)`

所以，因为第一个参数是“死”的，Vue 根本不知道通过谁去联系 `state`，**第二个参数（回调函数）也就永远不会执行**。

---

#### ✅ 正确写法：`watch(() => state.count, ...)`

当你传一个函数时，你传给 Vue 的不是“值”，而是一个**“查询指令”**。

**比喻：**
这就像你给了保安一个**对讲机**，并命令他：“你每隔一会，就用对讲机问一下总部现在的数字是多少。”

**Vue 的内部执行流程：**
1.  Vue 拿到你给的函数 `() => state.count`。
2.  Vue **运行** 这个函数。
3.  函数内部读取了 `state.count`。
4.  因为 `state` 是响应式的，一旦被读取，它就和 Vue 建立了“连接”（收集依赖）。
5.  Vue 记住了：“好，下次 `state.count` 变的时候，我要重新运行这个函数，拿到新值，然后跟旧值比对。”
6.  比对发现不一样 -> **触发第二个参数（回调函数），把新旧值传给你**。

---

### 2. 那为什么 `ref` 不需要写成函数？

你肯定会问：*“那 `ref` 也是数字啊，为什么 `count = ref(0)`，我写 `watch(count)` 就可以？”*

**因为 `ref` 根本不是数字，它是一个对象！**

```javascript
const count = ref(0);
// 实际上 count 长这样： { value: 0 }
```

当你写 `watch(count, ...)` 时：
1.  你传给 Vue 的是 `count` 这个**对象本身**（引用地址）。
2.  Vue 拿到这个对象，发现它是一个 Ref 对象。
3.  Vue 内部会自动帮你做一个操作：它可以直接监听这个对象的 `.value` 属性。

**比喻：**
*   `ref` 就像是一个**监视器屏幕**。你直接把屏幕交给保安，屏幕里的画面是会自己变的。
*   `state.count` 就像是**屏幕截图**。你把截图交给保安，截图是死的。

---

### 3. 终极总结（怎么记？）

并不是“有些要，有些不要”，而是看你传给 `watch` 的东西**是不是“活”的**。

*   **Ref 变量** (`count`)：
    *   它是对象，是**活的**。
    *   👉 **直接传**：`watch(count, cb)`

*   **Reactive 对象本身** (`state`)：
    *   它是对象（Proxy），是**活的**。
    *   👉 **直接传**：`watch(state, cb)`

*   **Reactive 里的某个属性** (`state.count`)：
    *   如果它是数字/字符串，它是**死的**（只是一个值）。
    *   👉 **必须用函数包活它**：`watch(() => state.count, cb)`
    *   *（通过函数每次重新去取值，让它变活）*

**一句话口诀：**
**如果不确定能不能直接传，统一都写成函数 `() => ...` 的形式，永远不会错！**
（因为 Ref 也可以写成 `() => count.value`，这和 `watch(count)` 效果是一样的）。





# vue2和vue3区别

这是一道非常经典的面试题。回答时不要只罗列特性，要**分维度**（响应式原理、代码组织、性能优化、TS支持等）来阐述，这样显得你逻辑清晰且理解深刻。

建议按照以下 **4 个核心维度** 进行回答：

---

### 1. 核心原理：响应式系统的重构 (最重要)

这是底层最大的区别，一定要最先说。

*   **Vue 2 (Object.defineProperty)**
    *   **机制**：利用 ES5 的 `Object.defineProperty` 对数据进行劫持。
    *   **痛点**：
        1.  **无法检测对象属性的添加/删除**（需要用 `Vue.set` / `this.$set`）。
        2.  **无法检测数组下标的变化**（直接 `arr[0] = 1` 不更新，需要重写数组方法）。
        3.  **初始化性能差**：如果数据量很大，Vue 2 需要递归遍历所有属性，一股脑全变成响应式（这就是之前说的 `freeze` 优化的原因）。
*   **Vue 3 (Proxy)**
    *   **机制**：利用 ES6 的 **`Proxy`** 代理整个对象。
    *   **优势**：
        1.  **全能拦截**：原生支持对象属性增删、数组索引修改、Map/Set 等数据结构。
        2.  **懒代理 (Lazy)**：只有当你访问嵌套对象时，才会去劫持下一层。初始化速度飞快，内存占用低。
        3.  **不需要 `$set` 了**。

### 2. 代码组织：Options API vs Composition API

这是开发体验上最大的区别。

*   **Vue 2 (Options API - 选项式)**
    *   **写法**：代码分散在 `data`, `methods`, `computed`, `watch` 里。
    *   **痛点**：当组件逻辑很复杂时（比如几百行代码），一个业务逻辑（比如“搜索功能”）的代码会被拆散在文件的各个角落，**“反复横跳”**难以维护。且逻辑复用困难（Mixins 存在命名冲突和来源不清晰的问题）。
*   **Vue 3 (Composition API - 组合式)**
    *   **写法**：使用 `setup`, `ref`, `reactive`, `computed` 等钩子函数。
    *   **优势**：
        1.  **逻辑关注点分离**：可以将同一个业务逻辑（如搜索）的所有代码（数据、方法、副作用）写在一起。
        2.  **逻辑复用神器 (Hooks)**：类似于 React Hooks，可以编写 `useSearch`、`useScroll` 这样的函数，极易复用且无副作用。
        3.  **更好的 Tree Shaking**：按需引入 API。

### 3. 性能优化：Diff 算法与编译优化

这是 Vue 3 “快”的原因，属于加分项。

*   **Vue 2 (全量 Diff)**
    *   数据更新时，Vue 2 会对比新旧虚拟 DOM 树的所有节点，哪怕这个节点是静态的（永远不变的 HTML）。
*   **Vue 3 (静态标记 Patch Flags)**
    *   **静态提升 (Hoist Static)**：编译时检测到静态节点（死数据），直接提升到渲染函数外，Diff 时直接跳过。
    *   **Patch Flags**：编译时给动态节点打上“标签”（比如：这个节点只有 class 会变）。Diff 时只对比变动的部分。
    *   **事件缓存**：缓存事件处理函数，减少重复创建。

### 4. 其他重要区别 (TypeScript, Fragment, Teleport)

*   **TypeScript 支持**
    *   **Vue 2**：对 TS 支持较弱，类型推断经常失效（尤其在 `this` 上），需要用装饰器等奇怪写法。
    *   **Vue 3**：源码完全用 TS 重写，对 TS 支持极好，类型推断非常智能。
*   **根节点 (Fragment)**
    *   **Vue 2**：模板（Template）必须**只能有一个**根节点（外层必须包一个 `div`）。
    *   **Vue 3**：支持多根节点（Fragment），减少了无意义的 DOM 层级。
*   **Teleport (传送门)**
    *   Vue 3 原生支持将组件渲染到 DOM 树的其他位置（比如把模态框 Modal 直接挂载到 `body` 下），Vue 2 需要第三方库。
*   **生命周期变化**
    *   `beforeDestroy` / `destroyed` 改名为 `beforeUnmount` / `unmounted`。

---

### 总结模板

> “Vue 2 和 Vue 3 的区别主要体现在以下几个方面：
>
> 1.  **响应式原理（最核心）**：
>     Vue 2 使用 `Object.defineProperty`，有初始化慢、不能监听数组下标和对象新增属性的缺陷。
>     Vue 3 改用 ES6 的 `Proxy`，解决了这些限制，并且是懒代理，性能更好。
>
> 2.  **代码组织方式**：
>     Vue 2 使用 Options API，逻辑容易分散，Mixins 复用性差。
>     Vue 3 引入了 Composition API（组合式 API），可以把相关业务逻辑组织在一起，利用 Hooks 极其方便地复用逻辑，也更利于 Tree-shaking。
>
> 3.  **性能优化**：
>     Vue 3 在编译阶段做了很多优化，比如**静态标记（Patch Flags）**和**静态提升**。在 Diff 过程中，可以直接跳过静态节点，只对比动态变化的属性，更新效率大幅提升。
>
> 4.  **TypeScript 支持**：
>     Vue 3 源码全由 TS 编写，对 TypeScript 的支持非常友好，类型推断更准确。
>
> 5.  **新特性**：
>     Vue 3 支持多根节点（Fragment）、Teleport（传送门）以及 Suspense 等新特性。”

### 追问

*   **问：Proxy 既然这么好，为什么 Vue 2 不用？**
    *   答：因为 Proxy 是 ES6 特性，无法被 Polyfill（无法在 IE 浏览器中完全模拟），Vue 2 为了兼容 IE 只能选 defineProperty。Vue 3 放弃了 IE 支持。
*   **问：Composition API 和 React Hooks 有什么区别？**
    *   答：Vue 的 `setup` 只运行一次，不存在 React Hooks 的闭包陷阱和依赖数组手动管理的问题，心智负担更小。





